* [Example Language](#example-language)
  * [Expression Types](#expression-types)
  * [Built-in-Operators](#built-in-operators)
  * [`let` Expressions](#`let`-expressions)
  * [Monomorphic Functions](#monomorphic-functions)
    * [Declaring Monomorphic Functions](#declaring-monomorphic-functions)
    * [Defining Monomorphic Functions](#defining-monomorphic-functions)
  * [Algebraic Data Types](#algebraic-data-types)
    * [Constructors](#constructors)
    * [Deconstructing ADT Values](#deconstructing-adt-values)
  * [Type Classes](#type-classes)
    * [Type Class Definition](#type-class-definition)
      * [Example Classes](#example-classes)
      * [Method Definitions](#method-definitions)
    * [Instance Definitions](#instance-definitions)
      * [Type Constraints](#type-constraints)
      * [Matching Method Definitions to Declarations](#matching-method-definitions-to-declarations)
      * [Instance Examples](#instance-examples)
```clojure
(ns y1)

```
# Example Language

In this module we define the semantics of an example language: $y_1$. The
language will syntactically resemble Clojure, but will be statically-typed.

Most of the semantics of the language will revolve around its type system.
In the following we will define it, step by step.

## Expression Types

We begin with defining `typeof`, a predicate to associate types to
expressions. In a way, the predicate `typeof` _defines_ the sub-language
of expressions because everything that can be given a type _is a valid
expression_.

We first define the base-case for this predicate. It uses the [built-in
predicate `inspect`](builtins.md#inspect) to understand the _kind_ of
expression, and calls `typeof-inspected` to pattern-match on the kind.
```clojure
(all [x t]
     (typeof x t) <-
     (exist [k]
            (inspect x k)
            (typeof-inspected k x t)))

```
Now we define the base cases for `typeof-inspected`, starting with the base
case, rejecting kinds that are not supported by a specific rule.
```clojure
(all [k x t]
     (typeof-inspected k x t ! x "is not a y1 expression"))

```
Now things that are not explicitly defined as $y_1$ expressions (so, all
things at this point) will result in this error message.
```clojure
(assert
 (exist [t] (typeof foo t) ! foo "is not a y1 expression"))

```
Next, we add cases for the different literal types.
```clojure
(all [x]
     (typeof-inspected :int x int))
(all [x]
     (typeof-inspected :float x float))
(all [x]
     (typeof-inspected :string x string))

(assert
 (typeof 42 int)
 (typeof 3.141593 float)
 (typeof "foo bar" string))

```
Vectors are assumed to have the same type for all elements. The type of
the first element is inferred and all elements need to match.
```clojure
(all [v t]
     (typeof-inspected :vector v (vector t)) <-
     (all-typesof v t))

```
It uses a new predicate, `all-typesof` to unify the types of all elements in
the vector to a single type `t`.
```clojure
(all [x t]
     (all-typesof x t ! "all-typesof does not support value" x))
(all [x xs t]
     (all-typesof [x & xs] t) <-
     (exist [t']
            (typeof x t)
            (all-typesof xs t')
            (= t t' ! "type mismatch between elements in a vector." x "is" t "while" xs "are" t')))
(all [t]
     (all-typesof [] t))


(assert
 (typeof [1] (vector int))
 (typeof [1 2 3] (vector int))
 (exist [t]
        (typeof [1 2 "three"] t)
        ! "type mismatch between elements in a vector." 2 "is" int
        "while" ["three"] "are" string))

```
## Built-in Operators

$y_0$ defines a few operators that can be used in expressions.

Arithmetic (binary) operators are defined for numeric types (`int` and
`float`), and require that the operands are of the same type. The returnede
type is the same as the operands.
```clojure
(all [a b t]
     (typeof (+ a b) t) <-
     (typeof a t)
     (exist [t']
            (typeof b t')
            (= t t' ! "Type mismatch in +." a "has type" t "while" b "has type" t')
            (numeric-type t)))

```
This definition provides a match for the `typeof` predicate directly. It
requires that both operands are of the same type. Then it requires that the
common type is numeric, using the `numeric-type` predicate that is defined

```clojure
(all [x]
     (numeric-type x ! x "is not a numeric type"))
(all [] (numeric-type int))
(all [] (numeric-type float))

(assert
 (typeof (+ 1 (+ 2 3)) int)
 (typeof (+ 1.1 (+ 2.2 3.3)) float)
 (exist [t]
        (typeof (+ 1 (+ 2.2 3.3)) t)
        ! "Type mismatch in +." 1 "has type" int "while" (+ 2.2 3.3) "has type" float)
 (exist [t]
        (typeof (+ "1" (+ "2" "3")) t)
        ! string "is not a numeric type"))

```
Since we have at least three more operators to define, let's automate the
process using the following [translation rule](statements.md):
```clojure
(all [op]
     (defbinumop op) =>
     (all [a b t]
          (typeof (op a b) t) <-
          (typeof a t)
          (exist [t']
                 (typeof b t')
                 (= t t' ! "Type mismatch in" op ":" a "has type" t "while" b "has type" t')
                 (numeric-type t))))

```
This repeats the rule for `(+ a b)`, but applies it to any operator that
will be defined using `defbinumop`.

Now we can define the rest of the operators and check that they are defined.
```clojure
(defbinumop -)
(defbinumop *)
(defbinumop /)
(defbinumop mod)

(assert
 (typeof (- 1 (* 2 3)) int)
 (typeof (/ 1.1 (mod 2.2 3.3)) float)
 (exist [t]
        (typeof (* 1 (/ 2.2 3.3)) t)
        ! "Type mismatch in" * ":" 1 "has type" int "while" (/ 2.2 3.3) "has type" float)
 (exist [t]
        (typeof (mod "1" (- "2" "3")) t)
        ! string "is not a numeric type"))

```
## `let` Expressions

Similar to Clojure, `let` expressions in $y_1$ have the following structure:
`(let [var-expr-pairs...] expr)` where `var-expr-pairs...` are zero or more
pairs of symbol and an expression and `expr` is an expression.

The type of such an expression is defined using the `typeof-let` predicate.
```clojure
(all [var-expr-pairs expr t]
     (typeof (let var-expr-pairs expr) t) <-
     (typeof-let var-expr-pairs expr t))

```
The base rule for `typeof-let` handles the case where the `let` expression
does not get a vector as its first argument.
```clojure
(all [x expr t]
     (typeof-let x expr t ! "let requires a vector as its first argument." x "is given"))

(assertx
 (exist [t] (typeof (let 2 3) t)
        ! "let requires a vector as its first argument." 2 "is given"))

```
Now we provide rules for a vector of at least two elements.
```clojure
(all [var var-expr var-expr-pairs expr t]
     (typeof-let [var var-expr & var-expr-pairs] expr t) <-
     (inspect var :symbol
              ! "Variable names in let expressions must be symbols." var "is given")
     (exist [var-t]
            (typeof var-expr var-t)
            (given (all [] (typeof var var-t))
                   (typeof-let var-expr-pairs expr t))))


```
Given a variable name `var` and an expression to assign to it `var-expr`,
we start by checking that `var` is a symbol. Then we infer the type of `
var-expr` and then [inject](conditions.md##given-conditions) a rule defining
the type of `var` as the type inferred for `var-expr` before recursing for
the rest of the list.

The termination condition is the case for an empty vector, which simply
infers the type of `let`'s second argument.
```clojure
(all [expr t]
     (typeof-let [] expr t) <-
     (typeof expr t))

```
Finally, we wish to provide an error for a case where the number of element
in the vector is odd.
```clojure
(all [x expr t]
     (typeof-let [x] expr t
                 ! "The vector in a let expression must consist of var,expression pairs."
                 x "is extra"))

```
Now we can check if our `let` expression behaves as expected.
```clojure
(assert
 (typeof (let [] 42) int)
 (typeof (let [n 42] (+ n 2)) int)
 (typeof (let [n 42.0
               m (+ n 2.0)] (* n m)) float))

```
## Monomorphic Functions

Monomorphic functions are functions for which both the parameter types and
the return type are fully defined with the function.

Monomorphic $y_1$ functions can be _declared_ or _defined_. The former just
provides the signature while the latter provides the signature along with
the implementation. Declared functions are assumed to have their definition
elsewhere, i.e., as built-in or foreign functions.

### Declaring Monomorphic Functions

Declaring a monomorphic function is done by the `declfn` statement. It is
defined using the following translation rule.
```clojure
(all [name params type]
     (declfn name params type) =>
     (assert
      (exist []
             (inspect name :symbol
                      ! "A function name must be a symbol." name "is given")
             (inspect params :vector
                      ! "Parameter types need to be provided as a vector."
                      params "is given")))
     (all [args]
          (typeof (name & args) type) <-
          (exist [arg-types]
                 (check-decl-types params args name))))

```
This translation rule translates a `declfn` definition, which takes a name,
a vector of params and a return type to two things:
1. An `assert` block, which performs two assertions: one to make sure the
name is a symbol and the other, to make sure that the parameters are given
as a vector.

These assertions run whenever a `declfn` statement is loaded. We can test
them using "empty" `given` conditions.
```clojure
(assert
 (given (declfn foo [int float] string))
 (given (declfn :foo [int float] string)
        ! "A function name must be a symbol." :foo "is given")
 (given (declfn foo (int float) string)
        ! "Parameter types need to be provided as a vector."
        (int float) "is given"))

```
The second statement generated by the rule defines calls to the declared
function as $y_1$ expressions. The rule uses `check-decl-types` to check
that the types of the arguments match the declared parameter types.
```clojure
(all [params args name]
     (check-decl-types params args name
                       ! "Parameter list must be a vector in call to check-decl-types."
                       params "is given"))
(all [param params args name]
     (check-decl-types [param & params] args name) <-
     (exist [arg args']
            (= args (arg & args')
               ! "Too few arguments in call to function" name "."
               "expecting" [param & params])
            (exist [arg-type]
                   (typeof arg arg-type)
                   (= param arg-type
                      ! "Type mismatch in call to function" name
                      arg "has type" arg-type "while" param "is expected"))
            (check-decl-types params args' name)))

(all [args name]
     (check-decl-types [] args name) <-
     (= args () ! "Too many arguments in call to" name "." args "are extra"))

```
The second rule is worth an explanation. It matches non-empty `params`
vectors. First, it pattern-matches the `args`, to see that there exists an
argument for the first (and therefore, each) parameter. Then we infer its
type using `typeof` and compare (`=`) it to the declared type. Finally,
we recurse to check the rest of the arguments.

```clojure
(assert
 (check-decl-types [int float string] (1 2.3 "four") foo)
 (check-decl-types [int float string] (1 2 "four") foo
                   ! "Type mismatch in call to function" foo
                   2 "has type" int "while" float "is expected")
 (check-decl-types [int float string] (1 2.3) foo
                   ! "Too few arguments in call to function" foo "."
                   "expecting" [string])
 (check-decl-types [int float string] (1 2.3 "four" five) foo
                   ! "Too many arguments in call to" foo "." (five) "are extra"))

```
So now we are ready to declare a few functions and use them in expressions.
We will start with conversion functions between primitive types.
```clojure
(declfn float [int] float)
(declfn round [float] int)
(declfn ceil [float] int)
(declfn floor [float] int)
(declfn trunc [float] int)
(declfn parse-int [string] int)
(declfn parse-float [string] float)
(declfn as-decimal [int] string)
(declfn as-hex [int] string)
(declfn as-scientific [float] string)


```
Now let us use some of these functions in expressions.
```clojure
(assert
 (typeof (round (+ (parse-float "3.0") (float 2))) int)
 (typeof (round (+ (parse-int "3.0") (float "2"))) int
         ! "Type mismatch in call to function" float
         "2" "has type" string "while" int "is expected"))

```
### Defining Monomorphic Functions

$y_1$ monomorphic functions are defined using the `defn` statement. Its
overall structure resembles the definition of the same name in Clojure, but
the parameters vector consists of name, type pairs.

As our running example, let us consider the following function:
```clojure
(defn square [x float]
  (* x x))

```
This function has a single parameter, `x` of type `float`. It multiplies it
by itself to give the square. The return type is not provided explicitly in
the definition. It is instead inferred to be `float`.

In the following, we work toward giving this definition meaning. We start by
defining the meaning of the `declvars-` statement. This is a statement that
will allow us to inject the parameters into the scope of the function's
body. Following Clojure's convention, the `-` at the end of the name
indicates that it is _private_, i.e., only used within this module.
```clojure
(all [var type vartypes]
     (declvars- [var type & vartypes]) =>
     (all [] (typeof var type))
     (declvars- vartypes))

```
`declvars-` takes a vector of name, type pairs and associates the types to
with the names. For example:
```clojure
(assert
 (given (declvars- [a int
                    b float
                    c string])
        (typeof a int)
        (typeof b float)
        (typeof c string)))

```
Now we are ready to define the translation rule for `defn`.
```clojure
(all [name params body]
     (defn name params body) =>
     (assert
      (exist []
             (inspect name :symbol
                      ! "The name of a function must be a symbol." name "is given")
             (inspect params :vector
                      ! "A function's parameter list must be a vector" params "is given")
             (given (declvars- params)
                    (exist [type]
                           (typeof body type)))))
     (all [args type]
          (typeof (name & args) type) <-
          (check-defn-types params args name)
          (given (declvars- params)
                 (typeof body type))))

```
A `defn` statement is translated into two statements. The first is an
`assert` block that checks three properties of the definition:
1. That the name is a symbol,
2. That the parameters are given in a vector, and
3. That with the parameters defined, the body is a valid expression.
```clojure
(assert
 (given (defn foo [a int
                   b float]
          (+ a (round b))))
 (given (defn "foo" [a int
                     b float]
          (+ a (round b)))
        ! "The name of a function must be a symbol." "foo" "is given")
 (given (defn foo (a int
                     b float)
          (+ a (round b)))
        ! "A function's parameter list must be a vector" (a int b float) "is given")
 (given (defn foo [a int
                   b float]
          (+ a b))
        ! "Type mismatch in +." a "has type" int "while" b "has type" float))

```
The second statement is a rule that accepts calls to the defined function as
$y_1$ expressions. It first checks that the argument types match the
parameter definition, then it repeats the same `given` condition as in the
assertion, but this time type `type` is bound to the expression's type.

The argument check is done using `check-defn-types`, which we define next.
```clojure
(all [params args name]
     (check-defn-types params args name
                       ! "check-defn-types requires a params vector as its first argument."
                       params "is given"))
(all [var var-type params args name]
     (check-defn-types [var var-type & params] args name) <-
     (exist [arg args']
            (= args (arg & args')
               ! "Too few arguments in call to function" name "."
               "missing argument for parameter" var)
            (exist [arg-type]
                   (typeof arg arg-type)
                   (= arg-type var-type
                      ! "Type mismatch for argument" var "of function" name "."
                      "The given argument" arg "is of type" arg-type
                      "while" var-type "is required")
                   (check-defn-types params args' name))))
(all [args name]
     (check-defn-types [] args name) <-
     (= args ()
        ! "Too many argument given to function" name "."
        args "are extra"))

```
We demonstrate it by inferring the type of an expression containing
`square`, as we defined it above.
```clojure
(assert
 (typeof (square 2.0) float)
 (exist [type]
        (typeof (square 2) type)
        ! "Type mismatch for argument" x "of function" square "."
        "The given argument" 2 "is of type" int
        "while" float "is required")
 (exist [type]
        (typeof (square) type)
        ! "Too few arguments in call to function" square "."
        "missing argument for parameter" x)
 (exist [type]
        (typeof (square 2.0 "please round up") type)
        ! "Too many argument given to function" square "."
        ("please round up") "are extra"))

```
## Algebraic Data Types

_Algebraic data types_ (_ADTs_) are user-defined types common in functional
programming languages. An ADT has one or more _constructors_, each
constructing a different variant of the type, allowing for expressing
complex, recursive data structures to be built.

We begin by introducing the `type` predicate. It takes a single argument and
succeeds if it is a type, or explains why not.
```clojure
(all [t]
     (type t ! t "is not a type"))

```
We have already encountered some $y_1$ built-in types, so let's define them
as such.
```clojure
(all [] (type int))
(all [] (type float))
(all [] (type string))
(all [] (type bool))
(all [t]
     (type (vector t)) <-
     (type t))
(all [t]
     (type (list t)) <-
     (type t))

(assert
 (type int)
 (type (list string))
 (type (list (vector foo)) ! foo "is not a type"))

```
The base rule for `adt-constructors` is defined here:
```clojure
(all [name params ctors]
     (adt-constructors name params ctors
                       ! name "is not an algebraic data type"))


```
In $y_1$, ADTs are defined using `deftype` definitions, which is defined as
follows.
```clojure
(all [name params ctors]
     (deftype name params & ctors) =>
     (assert
      (exist []
             (inspect name :symbol ! "Type name must be a symbol." name "is given"))
      (symbol-vector params)
      (given (decltypes- params)
             (type-constructors ctors)))
     (defctors- ctors name params)
     (all [args]
          (type (name & args)) <-
          (type-args args params))
     (all [params' ctors']
          (adt-constructors name params' ctors') <-
          (replace-meta params [params ctors] [params' ctors'])))

```
A defnition is translated to four parts:
1. An assertion that checks the validity of the definition itself.
2. A definition of the constructors.
3. A rule for `type`, defining instances of this ADT as types.
4. A rule for `adt-constructors` that lists the constructors for a given
   ADT.

`symbol-vector` simply checks that the input is a vector of symbols.
```clojure
(all [v]
     (symbol-vector v ! "Expected a vector, found" v))
(all [x xs]
     (symbol-vector [x & xs]) <-
     (inspect x :symbol ! "Expected a symbol, found" x)
     (symbol-vector xs))
(all [x xs]
     (symbol-vector []))

(assert
 (symbol-vector [a b c])
 (symbol-vector [a 2 c] ! "Expected a symbol, found" 2)
 (symbol-vector (a b c) ! "Expected a vector, found" (a b c)))

```
`decltypes-` declares all elements of the given vector as types.
```clojure
(all [t ts]
     (decltypes- [t & ts]) =>
     (all []
          (type t))
     (decltypes- ts))
(assert
 (given (decltypes- [a b c])
        (type a)
        (type b)
        (type c)))

```
`type-constructors` checks the vailidty of the given constructors.
```clojure
(all [ctors]
     (type-constructors ctors ! "type-constructors expects a list." ctors "was given"))
(all [ctor ctors]
     (type-constructors (ctor & ctors)) <-
     (exist [name params]
            (= ctor (name & params) ! "A constructor must be of the form (name args)." ctor "was given")
            (type-constructor-params params))
     (type-constructors ctors))
(all []
     (type-constructors ()))

(all [params]
     (type-constructor-params params ! "type-constructor-params takes a list." params "is given"))
(all [param params]
     (type-constructor-params (param & params)) <-
     (type param)
     (type-constructor-params params))
(all []
     (type-constructor-params ()))

(assert
 (type-constructors ((foo int float)
                     (bar string)))
 (type-constructors (:foo) ! "A constructor must be of the form (name args)." :foo "was given")
 (type-constructors ((foo x float)
                     (bar string)) ! x "is not a type")
 (type-constructors ((bar string)
                     (foo x float)) ! x "is not a type"))

```
`type-constructors` is used along with `decltypes-` to check that given that
all type parameters are types, the constructors parameters are types.
```clojure
(assert
 (given (deftype foo [t]
          (foo-list (list t))
          (foo-vec (vector t))))
 (given (deftype foo [t]
          (foo-list (list t))
          (foo-vec (vector x)))
        ! x "is not a type" "in" (deftype foo [t]
                                   (foo-list (list t))
                                   (foo-vec (vector x))))
 (given (deftype :foo [t]
          (foo-list (list t))
          (foo-vec (vector t)))
        ! "Type name must be a symbol." :foo "is given")
 (given (deftype foo [4]
          (foo-list (list t))
          (foo-vec (vector t)))
        ! "Expected a symbol, found" 4))

```
### Constructors

The second statement translated from a `deftype` statement is `defctors-`.
This statement translates to a series of `defctor-` statements.
```clojure
(all [ctor ctors name params]
     (defctors- (ctor & ctors) name params) =>
     (defctor- ctor name params)
     (defctors- ctors name params))


```
`defctor-` defines a single constructor.
```clojure
(all [cname cparams tname tparams]
     (defctor- (cname & cparams) tname tparams) =>
     (all [args tparams']
          (typeof (cname & args) (tname & tparams')) <-
          (exist [cparams' tparams-as-list]
                 (to-list tparams tparams-as-list)
                 (replace-meta tparams [tparams-as-list cparams] [tparams' cparams'])
                 (ctor-arg-types args cparams' cname))))

```
This definition translates `defctor-` to a rule for `typeof`, giving
constructor invocations a type. The naming convention used by this rule
makes a distinction between the _constructor's_ name and params (`c` prefix)
and the _type's_ name and params (`t` prefix).

The meta-variables `tparams` are replaced in both `tparams` and `cparams` to
form `tparams'` and `cparams'`. Then we infer the types of the arguments into
the free variables in `cparams'`.

The type inference is defined as follows.
```clojure
(all [args params name]
     (ctor-arg-types args params name
                     ! "ctor-arg-types takes a list as its first argument." args "was given"))
(all [arg args params name]
     (ctor-arg-types (arg & args) params name) <-
     (exist [p ps]
            (= params (p & ps)
               ! "Too many arguments in call to constructor" name ":" arg "is extra")
            (exist [t]
                   (typeof arg t)
                   (= p t
                      ! "Type mismatch in call to constructor" name
                      ": expected type" p "but inferred" t))
            (ctor-arg-types args ps name)))
(all [params name]
     (ctor-arg-types () params name) <-
     (exist []
            (= params ()
               ! "Too few arguments in call to constructor" name ":" params "are missing")))

(assert
 (ctor-arg-types (2 "foo") (int string) my-ctor)
 (ctor-arg-types (2 "foo") (int float) my-ctor
                 ! "Type mismatch in call to constructor" my-ctor
                 ": expected type" float "but inferred" string)
 (ctor-arg-types (2 "foo") (int string float) my-ctor
                 ! "Too few arguments in call to constructor" my-ctor ":" (float) "are missing")
 (ctor-arg-types (2 "foo" 3.14) (int string) my-ctor
                 ! "Too many arguments in call to constructor" my-ctor ":" 3.14 "is extra"))

```
The result is that defining an ADT defines its constructors.
```clojure
(assert
 (given (deftype foo [t]
          (foo-list (list t))
          (foo-vec (vector t)))
        (typeof (foo-vec [1 2 3]) (foo int))))

```
### Deconstructing ADT Values

Deconstruction of ADT values is done through `case` expressions. They have
the syntax `(case expr cases...)`, where `expr` is a single expression that
evaluates to a ADT value and `cases...` are pattern-expression pairs.

We define the type of `case` as follows.
```clojure
(all [expr cases t]
     (typeof (case expr & cases) t) <-
     (exist [expr-t]
            (typeof expr expr-t)
            (exist [name t-args]
                   (= expr-t (name & t-args)
                      ! "case requires expressions whose types are of the form (name args...)."
                      "An expression of type" expr-t "was given")
                   (exist [t-args-v ctors t']
                          (to-vec t-args t-args-v)
                          (adt-constructors name t-args-v ctors)
                          (cases-for-ctors ctors cases t')
                          (= t t' ! "Type mismatch in case expression. Expected" t "but inferred" t')))))

```
We first infer the type of `expr`. Then, after checking this is an ADT, we
find its constructors and check the cases against them.

The last part is done using `cases-for-ctors`:
```clojure
(all [ctors cases t]
     (cases-for-ctors ctors cases t
                      ! "cases-for-ctors takes a list of constructors as its first argument."
                      ctors "is given"))
(all [ctor ctors cases t]
     (cases-for-ctors (ctor & ctors) cases t) <-
     (exist [dtor expr r-cases]
            (= cases (dtor expr & r-cases)
               ! "case expression missing case for constructor" ctor)
            (case-for-ctor ctor dtor expr t)
            (cases-for-ctors ctors r-cases t)))
(all [cases t]
     (cases-for-ctors () cases t) <-
     (= cases ()
        ! "Too many cases in case express."
        cases "do not have corresponding constructors"))

(all [ctor dtor expr t]
     (case-for-ctor ctor dtor expr t
                    ! "Invalid constructor" ctor))
(all [name params dtor expr t]
     (case-for-ctor (name & params) dtor expr t) <-
     (exist [vars]
            (= dtor (name & vars)
               ! "Expected destructor for constructor" name "but got" dtor)
            (given (declparams- vars params)
                   (exist [t']
                          (typeof expr t')
                          (= t' t 
                             ! "Type mismatch in case" name ":"
                             "expected type" t "but inferred type" t')))))

```
The last rule defines the semantics of a _destructor_, a term of the form
`(name vars...)`, where `name` is the same name as one of the constructors
and `vars...` are zero or more symbols.

The important bit is that we declare these symbols based on the types they
take in the constructor, using the `declparams-` statement, defined below.
```clojure
(all [var vars params
      param r-params]
     (declparams- (var & vars) params) =>
     (assert
      (exist []
             (inspect var :symbol ! "Expected symbol, found" var)
             (= params (param & r-params)
                ! "Too many variables in destructor." (var & vars) "are not matched by constructor parameters.")))
     (all []
          (typeof var param))
     (declparams- vars r-params))
(all [params]
     (declparams- () params) =>
     (assert
      (exist []
             (= params ()
                ! "Too few variables in destructor. Missing variables for" params))))

(assert
 (given (declparams- (a b c) (int string float)))
 (given (declparams- (a 3 c) (int string float))
        ! "Expected symbol, found" 3)
 (given (declparams- (a b) (int string float))
        ! "Too few variables in destructor. Missing variables for" (float))
 (given (declparams- (a b c d) (int string float))
        ! "Too many variables in destructor." (d) "are not matched by constructor parameters."))

```
Now we are ready to test our `case` expression.
```clojure
(assert
 (given (deftype foo [t]
          (foo-list (list t))
          (foo-vec (vector t)))
        (given (declvars- [x (foo int)])
               (typeof (case x
                         (foo-list l) 3
                         (foo-vec v) 2) int))))

```
## Type Classes

In contrast to monomorphic functions, whose type signatures are constant,
_polimorphic functions_ are functions whose signature may change. Two types
of polimorphism supported by $y_1$: _parametric polimorphism_, in which some
types in the signature are completely open and can take any value, and
_ad-hoc polimorphism_, where some types in the signature can take certain
values, as long as some properties are guarantees for them.

Ad-hoc polimorphism is implemented using _type classes_, which we cover
here.

### Type Class Definition

A type-class is defined using the `defclass` statement, defined as follows.
```clojure
(all [name types methods]
     (defclass name types
       & methods) =>
     (assert
      (exist []
             (inspect name :symbol
                      ! "A class name needs to be a symbol." name "is given")
             (class-type-symbols types name)
             (class-methods methods)))
     (all [type' types']
          (name type' types'
                ! type' "is not a type in class" name))
     (defmethods- name types methods)
     (all [types' methods']
          (methods-for-class name types' methods') <-
          (replace-meta types [types methods] [types' methods'])))


```
This definition translates a `defclass` statement into three things:
1. An assertion that checks that the `name` is a symbol, `types` is a vector
   of symbols and that the `methods` are valid method definitions (we will
   define `class-type-symbols` and `class-methods` later).
2. A base rule for a predicate named after the class. This predicate takes
   two arguments, the `type` that is supposed to be a member of the class
   and `types`, auxiliary types that are derived from this type.
3. A definition of all methods as individual functions.
4. A rule for `methods-for-class`, providing the methods defined for this
   class. The base rule for this predicate is provided below. It replaces
   the symbols representing the types with free variables.
```clojure
(all [class types methods]
     (methods-for-class class types methods
                        ! class "is not defined as a type-class"))

```
`class-type-symbols` is defined as follows.
```clojure
(all [syms class]
     (class-type-symbols syms class
                         ! "A class types list needs to be a vector."
                         syms "is given"))
(all [sym syms class]
     (class-type-symbols [sym & syms] class) <-
     (inspect sym :symbol ! "A symbol expected." sym "was given")
     (class-type-symbols syms class))
(all [sym class]
     (class-type-symbols [sym] class) <-
     (inspect sym :symbol ! "A symbol expected." sym "was given"))
(all [class]
     (class-type-symbols [] class ! "Empty types list for class" class))

```
We will now define `class-methods`.
```clojure
(all [methods]
     (class-methods methods
                    ! "class-methods requires a list of methods." methods "is given"))
(all [method methods]
     (class-methods (method & methods)) <-
     (class-method method)
     (class-methods methods))
(all []
     (class-methods ()))

```
This definition applies `class-method` on each element. So let us define
`class-method`, and by that define what is legal as a method in a class.
```clojure
(all [method]
     (class-method method
                   ! method "is not a legal class method declaration"))
(all [name params type]
     (class-method (declfn name params type)) <-
     (inspect name :symbol
              ! "The name of a method must be a symbol." name "is given")
     (inspect params :vector
              ! "The parameter list of a method must be a vector." params "is given"))

```
After the base definition that rejects everything, we define a rule to
accept declarations similar to
[those of monomorphic functions](#declaring-monomorphic-functions).
Polymorphic functions are supported too, but we defer their definition until
later.

#### Example Classes

Now we can define our first type classes. `Show` is a class with one method:
`show`, which takes a single argument of a member type and returns a string
representing it.
```clojure
(defclass Show [t]
  (declfn show [t] string))

```
`Convertable-` is a less practical class, with one method: `convert-`. This
class demonstrates the idea of an _auxiliary type_ being introduced in
addition to the self-type (the first type in the types list).
```clojure
(defclass Convertable- [t t']
  (declfn convert- [t] t'))

```
`convert-` takes an argument of the self-type `t` and returns a value of
type `t'`, which is an auxiliary type. Each instance will then determine the
corresponding `t'` for each `t`. This demonstrates the "ad-hoc" in "ad-hoc
polymorphism".

These two class definitions define cases for `methods-for-class` and base
rules for predicates `Show` and `Convertable-`.
```clojure
(assert
 (methods-for-class Show [x] ((declfn show [x] string)))
 (methods-for-class Convertable- [x y] ((declfn convert- [x] y)))
 (Show foo [] ! foo "is not a type in class" Show)
 (exist [t']
        (Convertable- foo [t'])
        ! foo "is not a type in class" Convertable-))

```
Note that in the call to `methods-for-class` we can use any value in the
type list (we used `x` for `Show` and `x` and `y` for `Convertable-`).
Corresponding values appear in the method declaration.

Let us test a few bad definitions.
```clojure
(assert
 (given (defclass :Show [t])
        ! "A class name needs to be a symbol." :Show "is given")
 (given (defclass Show (t))
        ! "A class types list needs to be a vector." (t) "is given" "in" (defclass Show (t)))
 (given (defclass Show [])
        ! "Empty types list for class" Show "in" (defclass Show []))
 (given (defclass Show [:t])
        ! "A symbol expected." :t "was given")
 (given (defclass Show [t]
          (not a declfn))
        ! (not a declfn) "is not a legal class method declaration" "in" (defclass Show [t]
                                                                          (not a declfn))))

```
#### Method Definitions

A `defmethods-` statement translates into individual `defmethod-`
statements.
```clojure
(all [name types method methods]
     (defmethods- name types (method & methods)) =>
     (defmethod- name types method)
     (defmethods- name types methods))

```
`defmethod-` is defined for different kinds of methods. Currently, only
monomorphic methods are supported. The following is their definition.
```clojure
(all [class types method params ret-type]
     (defmethod- class types (declfn method params ret-type)) =>
     (all [args ret-type']
          (typeof (method & args) ret-type') <-
          (exist [self-type aux-types params']
                 (replace-meta types
                               [types params ret-type]
                               [[self-type & aux-types] params' ret-type'])
                 (check-decl-types params' args method)
                 (class self-type aux-types ! "in" (method & args)))))

```
With the above definition of the `Show` class (and no instances), we expect
type-checking on the `show` function to fail on the call to the class
predicate.
```clojure
(assert
 (exist [t]
        (typeof (show 2) t)
        ! int "is not a type in class" Show "in" (show 2)))

```
If we bridge this gap, we get a valid expression.
```clojure
(assert
 (given (all [] (Show int []))
        (typeof (show 2) string))
 (given (all [] (Convertable- int [float]))
        (typeof (convert- 2) float)))

```
### Instance Definitions

In contrast to [class definitions](#type-class-definition), which define new
type classes and declare their methods, _instance definitions_ define a type
or a family of types as a member / members of a type class, while providing
implementations for the declared methods.

We now proceed to defining the meaning of the `definstance` statement.
```clojure
(all [free-types constraints class types methods
      ;; Internal vars 
      constraints' t ts]
     (definstance free-types constraints class types
       & methods) =>
     (assert
      (symbol-vector free-types)
      (given (decltypes- free-types)
             (type-constraints constraints))
      (exist [classdef-types method-decls]
             (methods-for-class class classdef-types method-decls)
             (= classdef-types types
                ! "The types" types "do not match the type list" classdef-types
                "declared for class" class)
             (given (declconstraints- constraints)
                    (instance-method-defs methods method-decls)))
      (exist [types']
             (replace-meta free-types [types constraints] [types' constraints'])
             (= types' [t & ts])))
     (all []
          (class t ts) <-
          (check-constraints constraints')))

```
Like other definitions, `definstance` translates into an assertion and a
rule. However, here we see a special interaction between them. The assertion
binds some free variables that we marked as `Internal vars` in the
translation rule. These variables are then used in the rule. Specifically,
they replace meta-vars in the instance `free-types` with unbound variables.
These variables are then used in the rule.

The rule contributes a solution for the class predicate (the predicate
whose name is the name of the class), making the instance's type a solution.
The type `t`, used as key, is determined by the `assert` block. This make
sure that when the rule is being added, `t` corresponds to a concrete type,
contributing a concrete case to the predicate.

The assertion works as follows. First it checks that the given `free-types`
are all symbols given in a vector. Then it checks that if these symbols
were types, the given `constraints` were valid. Then it checks the matching
of the method definitions to the declarations in the `defclass`. Finally, it
replaces the meta-vars and prepares the terms for the instance rule, as
described above.

#### Type Constraints

Type constraints are terms of the form `(class type & types)`, where `class`
is a name of a class, `type` is a term representing an instance of this

`type-constraints` takes a vector of type constraints and succeeds if they
are valid.
```clojure
(all [constraints]
     (type-constraints constraints
                       ! "type-constraints takes a vector of constraints."
                       constraints "was given"))
(all [constraint constraints]
     (type-constraints [constraint & constraints]) <-
     (type-constraint constraint)
     (type-constraints constraints))
(all []
     (type-constraints []))

```
To define the validity of each type constraint, we first define
`match-constraint-types`, which checks that for each type in the vector
defined in the `defclass` there is a corresponding type in the type
constraint.
```clojure
(all [types classdef-types class]
     (match-constraint-types types classdef-types class
                             ! "match-constraint-types takes a list of types."
                             types "was given"))
(all [t ts classdef-t class]
     (match-constraint-types (t & ts) classdef-t class) <-
     (exist [classdef-t' classdef-ts']
            (= classdef-t [classdef-t' & classdef-ts']
               ! "Too many type arguments given to class" class ":"
               t "is unmatched")
            (type t)
            (match-constraint-types ts classdef-ts' class)))
(all [classdef-t class]
     (match-constraint-types () classdef-t class) <-
     (= classdef-t []
        ! "Too few arguments given to class" class ":"
        classdef-t "are missing"))

(assert
 (match-constraint-types (int string) [x y] MyClass)
 (match-constraint-types (int foo) [x y] MyClass
                         ! foo "is not a type")
 (match-constraint-types (int string float) [x y] MyClass
                         ! "Too many type arguments given to class" MyClass ":"
                         float "is unmatched")
 (match-constraint-types (int) [x y] MyClass
                         ! "Too few arguments given to class" MyClass ":"
                         [y] "are missing"))

```
`type-constraint` succeeds if the given term is a valid type constraint.
```clojure
(all [constraint]
     (type-constraint constraint
                      ! "Expected (class types...). Found" constraint))
(all [class types]
     (type-constraint (class & types)) <-
     (exist [classdef-types _method-decls]
            (methods-for-class class classdef-types _method-decls)
            (match-constraint-types types classdef-types class)))

(assert
 (type-constraints [(Show string) (Convertable- int float)])
 (type-constraints [(Show string) (Convertable- int foo)]
                   ! foo "is not a type")
 (type-constraints [(Show string) (NotAClass int float)]
                   ! NotAClass "is not defined as a type-class")
 (type-constraints [(Show string int) (Convertable- int float)]
                   ! "Too many type arguments given to class" Show ":"
                   int "is unmatched")
 ;; TODO: This should fail.
 (type-constraints [(Show) (Convertable- int)]))

```
Given constraints with actual types, `check-constraints` checks that they
hold, i.e., that there are instances to match them.
```clojure
(all [constraints]
     (check-constraints constraints
                        ! "check-constraints expects a vector of constraints."
                        constraints "was given"))
(all [constraint constraints]
     (check-constraints [constraint & constraints]) <-
     (check-constraint constraint)
     (check-constraints constraints))
(all []
     (check-constraints []))

```
This is acheived by calling the class predicate for each constraint.
```clojure
(all [constraint]
     (check-constraint constraint
                       ! "Expected (class types...). Found" constraint))
(all [class types]
     (check-constraint (class & types)) <-
     (exist [t ts]
            (= types (t & ts) ! "A type constraint must contain at least one type.")
            (exist [ts-v]
                   (to-vec ts ts-v)
                   (class t ts-v))))

(assert
 (given (all [] (Show int []))
        (check-constraint (Show int)))
 (given (all [] (Convertable- int [float]))
        (check-constraint (Convertable- int float)))
 (check-constraint (Show)
                   ! "A type constraint must contain at least one type."))

```
Finally, constraints can be used to inject assumptions into a scope.
`declconstraints-` does this for a vector of constraints.
```clojure
(all [class type types types-vec constraints]
     (declconstraints- [(class type & types) & constraints]) =>
     (assert
      (to-vec types types-vec))
     (all []
          (class type types-vec))
     (declconstraints- constraints))

(assert
 (given (declconstraints- [(Show t) (Convertable- t1 t2)])
        (exist []
               (Show t [])
               (Convertable- t1 [t2]))))

```
#### Matching Method Definitions to Declarations

`defclass` declares methods that need to be defined for every instance.
These methods need to be defined in each `definstance` of that class, at the
same order.

`instance-method-defs` takes a list of method definitions and a list of
declarations and succeeds if the two match.
```clojure
(all [defs decls]
     (instance-method-defs defs decls
                           ! "instance-method-defs takes a list of definitions."
                           defs "was given"))
(all [def defs decls]
     (instance-method-defs (def & defs) decls) <-
     (exist [decl decls']
            (= decls (decl & decls')
               ! "Too many method definitions in instance." def "is unmatched")
            (instance-method-def-for-decl decl def)
            (instance-method-defs defs decls')))
(all [decls]
     (instance-method-defs () decls) <-
     (= decls ()
        ! "Too few method definitions in instance. Definitions for" decls "are missing"))

(all [def decl]
     (instance-method-def-for-decl decl def ! decl "is not a method declaration"))

```
So far we have only seen one type of method declaration: the one for
monomorphic methods. The following rule accepts matching definitions.
```clojure
(all [name param-types ret-type def]
     (instance-method-def-for-decl (declfn name param-types ret-type) def) <-
     (exist [param-names body]
            (= def (defn name param-names body)
               ! "Expected a defn of method" name "but found" def)
            (symbol-vector param-names)
            (exist [inferred-type]
                   (given (defparams- param-names param-types)
                          (typeof body inferred-type))
                   (= inferred-type ret-type
                      ! "The body of method" name "should evaluate to type" ret-type
                      "but" inferred-type "is inferred"))))

```
This rule matches a `declfn` method declaration. It first checks that the
corresponding definition is a `defn` of the same name. Then it checks that
the parameter names are given in a vector of symbols. Then it defines these
params as having the types mentioned in the declaration and tries to infer
the type of the body, assuming this definition. The type should match the
type declared in the declaration.

Defining the parameters is done using the following translation rule.
```clojure
(all [name names type types]
     (defparams- [name & names] [type & types]) =>
     (all []
          (typeof name type))
     (defparams- names types))

```
#### Instance Examples

Here are some definitions of instances for the `Show` and `Convertable-`.
```clojure
(definstance [] [] Show [string]
  (defn show [s]
    s))
(definstance [] [] Show [int]
  (defn show [n]
    (as-decimal n)))
(definstance [] [] Convertable- [float int]
  (defn convert- [n]
    (round n)))

```
These definitions are for concrete types. In the first two we define two
instances for `Show`: `int` and `string`. We use `defn` to define each
method declared using `declfn` in the corresponding `defclass`. In the third
definition we define `float` as an instance of `Convertable-`, which
converts the input to `int` by rounding it.

The effect of these definitions is that the methods (`show` and `convert-`)
are now defined for a select input types. 
```clojure
(assert
 (typeof (show "foo") string)
 (typeof (show 42) string)
 (exist [t]
        (typeof (show 42.0) t)
        ! float "is not a type in class" Show "in" (show 42.0))
 (typeof (convert- 42.0) int))

```
Following are some erroneous examples, showing the different checks we have
defined.
```clojure
(assert
 (given (definstance [] [] Show [string]
          (defn display [s]
            s))
        ! "Expected a defn of method" show "but found" (defn display [s]
                                                         s))
 (given (definstance [] [] Show [string]
          (defn show (s)
            s))
        ! "Expected a vector, found" (s) "in" (definstance [] [] Show [string]
                                                (defn show (s)
                                                  s)))
 (given (definstance [] [] Show [int]
          (defn show [s]
            s))
        ! "The body of method" show "should evaluate to type" string
        "but" int "is inferred"))

```
In the next example we define a polymorphic instance. We first define
`showable-`, a container type for values of any type.
```clojure
(deftype showable- [t] (showable- t))

```
We now define `(showable- t)` as an instance of `Convertable-` for any `t` in
`Show`, as follows:
```clojure
(definstance [t] [(Show t)] Convertable- [(showable- t) string]
  (defn convert- [x]
    (case x
      (showable- v) (show v))))
```

