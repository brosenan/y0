* [$c_0$ is not C](#$c_0$-is-not-c)
  * [Types](#types)
  * [Expressions](#expressions)
  * [Statements](#statements)
  * [Function Definitions](#function-definitions)
```clojure
(ns c0)

```
# $c_0$ is not C

## Types
```clojure
(all [t]
     (type t ! t "is not a type"))

(all [t]
     (type [:type t]) <-
     (type t))

(all []
     (type "int"))
(all []
     (type "float"))

```
## Expressions
```clojure
(all [x t]
     (typeof x t ! "Invalid expression" x))
(all [x t]
     (typeof [:expr x] t) <-
     (typeof x t))
(all [n]
     (typeof [:int n] "int"))
(all [n]
     (typeof [:float n] "float"))

```
## Statements

```clojure
(all [stms]
     (statements stms ! "Expected a vector of statements. Found" stms))
(all [stm stms]
     (statements [stm & stms]) <-
     (statement stm stms))
(all []
     (statements []))

(all [stm stms]
     (statement stm stms ! "Invalid statement" stm))

(all [t var val stms]
     (statement [:assign t var val] stms) <-
     (type t)
     (exist [t']
            (typeof val t')
            (= t t' ! "Type mismatch. Variable" var "was given type" t
               "but was assign value of type" t'))
     (given (declvar var t)
            (statements stms)))

(all [var t]
     (declvar var t) =>
     (all [] (typeof var t)))

```
## Function Definitions
```clojure
(all [l]
     (arg-defs l ! l "is not an arg-def"))

(all [arg args]
     (arg-defs [arg & args]) <-
     (arg-def arg)
     (arg-defs args))
(all []
     (arg-defs []))

(all [def]
     (arg-def def ! def "is not an argument definition"))
(all [t name]
     (arg-def [:arg_def t name]) <-
     (type t))
(all []
     (arg-def :arg_defs))

(all [t name args stms]
     [:func_def t name args & stms] =>
     (assert
      (type t)
      (arg-defs args)
      (given (declargs args)
             (statements stms))))

(all [arg args]
     (declargs [arg & args]) =>
     (declarg arg)
     (declargs args))

(all [t var]
     (declarg [:arg_def t var]) =>
     (declvar var t))
```

