(ns c0)

;; # $c_0$ is not C

;; ## Function Definition
(all [t name args stmts]
     [:func_def t name args & stmts] =>
     (assert
      (statements stmts)))

;; ## Statements
(all [stmts]
     (statements stmts ! "Invalid statement vector:" stmts))

(all [stmt stmts]
     (statements [stmt & stmts]) <-
     (given stmt
            (statements stmts)))
(all []
     (statements []))

(all [t v x]
     [:vardef t v x] =>
     (assert
      (type t)
      (expr-of-type x t))
     (all [] (typeof v t)))

(all [v x
      t]
     [:implicit_vardef v x] =>
     (assert
      (typeof x t))
     (all [] (typeof v t)))

(all [alias t]
     [:type_alias_def alias t] =>
     (assert
      (given (all []
                  (type-alias alias t))
             (type t)))
     (all []
          (type-alias alias t))
     (all []
          (defmembers [:type_alias alias]) =>
          (defmembers t)))

;; ## Expressions
(all [x t]
     (expr-of-type x t) <-
     (exist [t-unaliased]
            (unalias t t-unaliased)
            (exist [t']
                   (typeof x t')
                   (exist [t'-unaliased]
                          (unalias t' t'-unaliased)
                          (assignable t-unaliased t'-unaliased
                                      ! "Type mismatch. Expression" x "is of type" t'
                                      "but type" t "was expected")))))

(all [x t]
     (expr-of-type [:expr x] t) <-
     (expr-of-type x t))

(all [x y]
     (typeof x t ! "Invalid expression" x))

(all [x t]
     (typeof [:expr x] t) <-
     (typeof x t))

(all [n t]
     (expr-of-type [:float n] t) <-
     (float-type t ! "when assigning floating point literal" n))

(all [n t]
     (expr-of-type [:int n] t))

(all [n t]
     (typeof [:int n] [:int64_type]))

(all [n t]
     (typeof [:float n] [:float64_type]))

(all [t]
     (expr-of-type [:null] t) <-
     (exist [t']
            (= t [:pointer_type t']
               ! ? "can only be assigned to a pointer type. Given " t "instead")))

(all [xs t]
     (expr-of-type [:initializer_list & xs] t) <-
     (initialization t xs))
(all [xs t]
     (typeof [:initializer_list & xs] t
             ! "Cannot infer the type of initializer list" ?))
(all [xs t]
     (typeof [:typed_initializer_list t & xs] t) <-
     (initialization t xs))

(all [x m t]
     (typeof [:qualified_expr x m] t) <-
     (exist [tx]
            (typeof x tx)
            (given (defmembers tx)
                   (typeof m t))))

;; ### Initializers
(all [t xs]
     (initialization t xs ! "Cannot use an initializer list for type" t))

(all [alias xs]
     (initialization [:type_alias alias] xs) <-
     (exist [t]
            (type-alias alias t)
            (initialization t xs)))

(all [fds xs]
     (initialization [:struct_type & fds] xs) <-
     (member-initializations fds xs))

;; ### Arithmetic Operators
(all [op]
     (arith-binop op) =>
     (all [t a b]
          (expr-of-type [op a b] t) <-
          (expr-of-type a t)
          (expr-of-type b t)
          (numeric-type t ! "in expression" ?))
     (all [t a b]
          (typeof [op a b] t) <-
          (exist [t']
                 (typeof a t)
                 (typeof b t')
                 (= t t'
                    ! "The two operands of" ? "do not agree on types."
                    a "has type" t "while" b "has type" t')
                 (numeric-type t ! "in expression" ?))))
(all [op]
     (arith-uniop op) =>
     (all [t a]
          (expr-of-type [op a] t) <-
          (expr-of-type a t)
          (numeric-type t ! "in expression" ?))
     (all [t a]
          (typeof [op a] t) <-
          (typeof a t)
          (numeric-type t ! "in expression" ?)))

(arith-binop :add)
(arith-binop :sub)
(arith-binop :mult)
(arith-binop :div)
(arith-binop :mod)

(arith-uniop :minus)

;; ### Pointers
(all [x t]
     (typeof [:addressof x] [:pointer_type t]) <-
     (typeof x t))

;; ## Types
(all [t]
     (type t ! t "is not a type"))

(all [t]
     (type [:pointer_type t]) <-
     (type t))

(all [alias]
     (type [:type_alias alias]) <-
     (exist [t]
            (type-alias alias t)))

(all [fds]
     (type [:struct_type & fds]) <-
     (given (defall fds)))

(all [t]
     (float-type t ! t "is not a floating-point type"))

(all [] (float-type [:float32_type]))
(all [] (float-type [:float64_type]))

(all [alias t]
     (type-alias alias t ! alias "is not a type alias"))

(all [alias]
     (float-type [:type_alias alias]) <-
     (exist [t]
            (type-alias alias t)
            (float-type t)))

;; ### Numeric Types
(all [t]
     (numeric-type t ! t "is not a numeric type"))

(all [t ts]
     (def-numeric-types [t & ts]) =>
     (all []
          (type t))
     (all []
          (numeric-type t))
     (all [xs]
          (initialization t xs) <-
          (exist [x]
                 (= xs [x]
                    ! "An initializer list for a numeric type must have exactly one element."
                    xs "is given")
                 (exist [t']
                        (typeof x t')
                        (numeric-type t' ! "in assignment to numeric type" t))))
     (def-numeric-types ts))

(def-numeric-types [[:int8_type] [:int16_type] [:int32_type] [:int64_type]
                    [:uint8_type] [:uint16_type] [:uint32_type] [:uint64_type]
                    [:float32_type] [:float64_type]])

(all [t]
     (unalias t t))

(all [alias t]
     (unalias [:type_alias alias] t) <-
     (exist [t']
            (type-alias alias t')
            (unalias t' t)))

;; ### Type Assignability
(all [t1 t2]
     (assignable t1 t2) <-
     (= t1 t2))

(all [t1-kw t2]
     (assignable [t1-kw] t2) <-
     (exist [assignable-to-t1]
            (symbolize assignable-to [t1-kw] assignable-to-t1)
            (assignable-to-t1 t2)))

(all [t src-ts
      assignable-to-t]
     (def-assignable t src-ts) =>
     (assert
      (exist [t-kw]
             (= t [t-kw])
             (symbolize assignable-to [t-kw] assignable-to-t)))
     (all [t']
          (assignable-to-t t' 
                           ! "Type" t' "cannot be used in this context:"))
     (all []
          (assignable-to-t t))
     (def-assignable' assignable-to-t src-ts))

(all [assignable-to-t src-t src-ts]
     (def-assignable' assignable-to-t [src-t & src-ts]) =>
     (all []
          (assignable-to-t src-t))
     (def-assignable' assignable-to-t src-ts))

(def-assignable [:int8_type] [])
(def-assignable [:int16_type] [[:int8_type]
                               [:uint8_type]])
(def-assignable [:int32_type] [[:int8_type] [:int16_type]
                               [:uint8_type] [:uint16_type]])
(def-assignable [:int64_type] [[:int8_type] [:int16_type] [:int32_type]
                               [:uint8_type] [:uint16_type] [:uint32_type]])

(def-assignable [:uint8_type] [])
(def-assignable [:uint16_type] [[:uint8_type]
                                [:int8_type]])
(def-assignable [:uint32_type] [[:uint8_type] [:uint16_type]
                                [:int8_type] [:int16_type]])
(def-assignable [:uint64_type] [[:uint8_type] [:uint16_type] [:uint32_type]
                                [:int8_type] [:int16_type] [:int32_type]])

(def-assignable [:float32_type] [[:uint8_type] [:uint16_type]
                                 [:int8_type] [:int16_type]])
(def-assignable [:float64_type] [[:float32_type]
                                 [:uint8_type] [:uint16_type] [:uint32_type]
                                 [:int8_type] [:int16_type] [:int32_type]])

;; ## Structs

(all [fds]
     (defmembers [:struct_type & fds]) =>
     (defall fds))

(all [t]
     (defmembers [:pointer_type t]) =>
     (defmembers t))

(all [d ds]
     (defall [d & ds]) =>
     d
     (defall ds))

(all [t v]
     [:field_def t v] =>
     (assert
      (type t))
     (all []
          (typeof v t)))

(all [fds xs]
     (member-initializations fds xs ! fds "is not a member definition list"))

(all [fd fds xs]
     (member-initializations [fd & fds] xs) <-
     (exist [x xs']
            (= xs [x & xs']
               ! "Too few elements in initializer list." fd "does not have an initializer")
            (member-initialization fd x)
            (member-initializations fds xs')))

(all [xs]
     (member-initializations [] xs) <-
     (= xs [] ! "Too many elements in initializer list." xs "are extra"))

(all [fd x]
     (member-initialization fd x ! fd "is not a member definition"))

(all [t v x]
     (member-initialization [:field_def t v] x) <-
     (expr-of-type x t))

;; ### Unions

(all [name opts]
     [:union_def name & opts] =>
     (assert
      (given (defall opts)))
     (defoptions opts name))

(all [t v]
     [:option_def t v] =>
     (assert
      (type t))
     (all []
          (option v t)))

(all [opt opts uname]
     (defoptions [opt & opts] uname) =>
     (defoption opt uname)
     (defoptions opts uname))

(all [t v uname]
     (defoption [:option_def t v] uname) =>
     (all [t']
          (typeof v t'
                  ! "Cannot access field" v "of union" uname
                  "outside a case expression")))

(all [n opt-defs x]
     (member-initialization [:union_def n & opt-defs] x) <-
     (exist [opt val]
            (= x [:option_initializer opt val] 
               ! "Initialization for union" n
               "needs to be done with an option initializer, but" x "was given")
            (given (defall opt-defs)
                   (exist [t]
                          (option opt t ! "in union" n)
                          (expr-of-type val t ! "for option" opt)))))

(all [opt t]
     (option opt t ! opt "is not an option"))
