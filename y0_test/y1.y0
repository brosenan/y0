(ns y1)

;; # Example Language

;; In this module we define the semantics of an example language: $y_1$. The
;; language will syntactically resemble Clojure, but will be statically-typed.

;; Most of the semantics of the language will revolve around its type system.
;; In the following we will define it, step by step.

;; ## Expression Types

;; We begin with defining `typeof`, a predicate to associate types to
;; expressions. In a way, the predicate `typeof` _defines_ the sub-language
;; of expressions because everything that can be given a type _is a valid
;; expression_.

;; We first define the base-case for this predicate. It uses the [built-in
;; predicate `inspect`](builtins.md#inspect) to understand the _kind_ of
;; expression, and calls `typeof-inspected` to pattern-match on the kind.
(all [x t]
     (typeof x t) <-
     (exist [k]
            (inspect x k)
            (typeof-inspected k x t)))

;; Now we define the base cases for `typeof-inspected`, starting with the base
;; case, rejecting kinds that are not supported by a specific rule.
(all [k x t]
     (typeof-inspected k x t ! x "is not a y1 expression"))

;; Now things that are not explicitly defined as $y_1$ expressions (so, all
;; things at this point) will result in this error message.
(assert
 (exist [t] (typeof foo t) ! foo "is not a y1 expression"))

;; Next, we add cases for the different literal types.
(all [x]
     (typeof-inspected :int x int))
(all [x]
     (typeof-inspected :float x float))
(all [x]
     (typeof-inspected :string x string))

(assert
 (typeof 42 int)
 (typeof 3.141593 float)
 (typeof "foo bar" string))

;; Vectors are assumed to have the same type for all elements. The type of
;; the first element is inferred and all elements need to match.
(all [v t]
     (typeof-inspected :vector v (vector t)) <-
     (all-typesof v t))

;; It uses a new predicate, `all-typesof` to unify the types of all elements in
;; the vector to a single type `t`.
(all [x t]
     (all-typesof x t ! "all-typesof does not support value" x))
(all [x xs t]
     (all-typesof [x & xs] t) <-
     (exist [t']
            (typeof x t)
            (all-typesof xs t')
            (= t t' ! "type mismatch between elements in a vector." x "is" t "while" xs "are" t')))
(all [t]
     (all-typesof [] t))


(assert
 (typeof [1] (vector int))
 (typeof [1 2 3] (vector int))
 (exist [t]
        (typeof [1 2 "three"] t)
        ! "type mismatch between elements in a vector." 2 "is" int
        "while" ["three"] "are" string))

;; ## Built-in Operators

;; $y_0$ defines a few operators that can be used in expressions.

;; Arithmetic (binary) operators are defined for numeric types (`int` and
;; `float`), and require that the operands are of the same type. The returnede
;; type is the same as the operands.
(all [a b t]
     (typeof (+ a b) t) <-
     (typeof a t)
     (exist [t']
            (typeof b t')
            (= t t' ! "Type mismatch in +." a "has type" t "while" b "has type" t')
            (numeric-type t)))

;; This definition provides a match for the `typeof` predicate directly. It
;; requires that both operands are of the same type. Then it requires that the
;; common type is numeric, using the `numeric-type` predicate that is defined
; as follows:

(all [x]
     (numeric-type x ! x "is not a numeric type"))
(all [] (numeric-type int))
(all [] (numeric-type float))

(assert
 (typeof (+ 1 (+ 2 3)) int)
 (typeof (+ 1.1 (+ 2.2 3.3)) float)
 (exist [t]
        (typeof (+ 1 (+ 2.2 3.3)) t)
        ! "Type mismatch in +." 1 "has type" int "while" (+ 2.2 3.3) "has type" float)
 (exist [t]
        (typeof (+ "1" (+ "2" "3")) t)
        ! string "is not a numeric type"))

;; Since we have at least three more operators to define, let's automate the
;; process using the following [translation rule](statements.md):
(all [op]
     (defbinumop op) =>
     (all [a b t]
          (typeof (op a b) t) <-
          (typeof a t)
          (exist [t']
                 (typeof b t')
                 (= t t' ! "Type mismatch in" op ":" a "has type" t "while" b "has type" t')
                 (numeric-type t))))

;; This repeats the rule for `(+ a b)`, but applies it to any operator that
;; will be defined using `defbinumop`.

;; Now we can define the rest of the operators and check that they are defined.
(defbinumop -)
(defbinumop *)
(defbinumop /)
(defbinumop mod)

(assert
 (typeof (- 1 (* 2 3)) int)
 (typeof (/ 1.1 (mod 2.2 3.3)) float)
 (exist [t]
        (typeof (* 1 (/ 2.2 3.3)) t)
        ! "Type mismatch in" * ":" 1 "has type" int "while" (/ 2.2 3.3) "has type" float)
 (exist [t]
        (typeof (mod "1" (- "2" "3")) t)
        ! string "is not a numeric type"))

;; ## `let` Expressions

;; Similar to Clojure, `let` expressions in $y_1$ have the following structure:
;; `(let [var-expr-pairs...] expr)` where `var-expr-pairs...` are zero or more
;; pairs of symbol and an expression and `expr` is an expression.

;; The type of such an expression is defined using the `typeof-let` predicate.
(all [var-expr-pairs expr t]
     (typeof (let var-expr-pairs expr) t) <-
     (typeof-let var-expr-pairs expr t))

;; The base rule for `typeof-let` handles the case where the `let` expression
;; does not get a vector as its first argument.
(all [x expr t]
     (typeof-let x expr t ! "let requires a vector as its first argument." x "is given"))

;; Now we provide rules for a vector of at least two elements.
(all [var var-expr var-expr-pairs expr t]
     (typeof-let [var var-expr & var-expr-pairs] expr t) <-
     (inspect var :symbol
              ! "Variable names in let expressions must be symbols." var "is given")
     (exist [var-t]
            (typeof var-expr var-t)
            (given (all [] (typeof var var-t))
                   (typeof-let var-expr-pairs expr t))))


;; Given a variable name `var` and an expression to assign to it `var-expr`,
;; we start by checking that `var` is a symbol. Then we infer the type of `
;; var-expr` and then [inject](conditions.md##given-conditions) a rule defining
;; the type of `var` as the type inferred for `var-expr` before recursing for
;; the rest of the list.

;; The termination condition is the case for an empty vector, which simply
;; infers the type of `let`'s second argument.
(all [expr t]
     (typeof-let [] expr t) <-
     (typeof expr t))

;; Finally, we wish to provide an error for a case where the number of element
;; in the vector is odd.
(all [x expr t]
     (typeof-let [x] expr t
                 ! "The vector in a let expression must consist of var,expression pairs."
                 x "is extra"))

;; Now we can check if our `let` expression behaves as expected.
(assert
 (typeof (let [] 42) int)
 (typeof (let [n 42] (+ n 2)) int)
 (typeof (let [n 42.0
               m (+ n 2.0)] (* n m)) float))

;; ## Monomorphic Functions

;; Monomorphic functions are functions for which both the parameter types and
;; the return type are fully defined with the function.

;; Monomorphic $y_1$ functions can be _declared_ or _defined_. The former just
;; provides the signature while the latter provides the signature along with
;; the implementation. Declared functions are assumed to have their definition
;; elsewhere, i.e., as built-in or foreign functions.

;; ### Declaring Monomorphic Functions

;; Declaring a monomorphic function is done by the `declfn` statement. It is
;; defined using the following translation rule.
(all [name params type]
     (declfn name params type) =>
     (assert
      (exist []
             (inspect name :symbol
                      ! "A function name must be a symbol." name "is given")
             (inspect params :vector
                      ! "Parameter types need to be provided as a vector."
                      params "is given")))
     (all [args]
          (typeof (name & args) type) <-
          (exist [arg-types]
                 (check-decl-types params args name))))

;; This translation rule translates a `declfn` definition, which takes a name,
;; a vector of params and a return type to two things:
;; 1. An `assert` block, which performs two assertions: one to make sure the
;; name is a symbol and the other, to make sure that the parameters are given
;; as a vector.

;; These assertions run whenever a `declfn` statement is loaded. We can test
;; them using "empty" `given` conditions.
(assert
 (given (declfn foo [int float] string))
 (given (declfn :foo [int float] string)
        ! "A function name must be a symbol." :foo "is given"
        "in" (declfn :foo [int float] string))
 (given (declfn foo (int float) string)
        ! "Parameter types need to be provided as a vector."
        (int float) "is given"
        "in" (declfn foo (int float) string)))

;; The second statement generated by the rule defines calls to the declared
;; function as $y_1$ expressions. The rule uses `check-decl-types` to check
;; that the types of the arguments match the declared parameter types.
(all [params args name]
     (check-decl-types params args name
                       ! "Parameter list must be a vector in call to check-decl-types."
                       params "is given"))
(all [param params args name]
     (check-decl-types [param & params] args name) <-
     (exist [arg args']
            (= args (arg & args')
               ! "Too few arguments in call to function" name "."
               "expecting" [param & params])
            (exist [arg-type]
                   (typeof arg arg-type)
                   (= param arg-type
                      ! "Type mismatch in call to function" name
                      arg "has type" arg-type "while" param "is expected"))
            (check-decl-types params args' name)))

(all [args name]
     (check-decl-types [] args name) <-
     (= args () ! "Too many arguments in call to" name "." args "are extra"))

;; The second rule is worth an explanation. It matches non-empty `params`
;; vectors. First, it pattern-matches the `args`, to see that there exists an
;; argument for the first (and therefore, each) parameter. Then we infer its
;; type using `typeof` and compare (`=`) it to the declared type. Finally,
;; we recurse to check the rest of the arguments.

(assert
 (check-decl-types [int float string] (1 2.3 "four") foo)
 (check-decl-types [int float string] (1 2 "four") foo
                   ! "Type mismatch in call to function" foo
                   2 "has type" int "while" float "is expected")
 (check-decl-types [int float string] (1 2.3) foo
                   ! "Too few arguments in call to function" foo "."
                   "expecting" [string])
 (check-decl-types [int float string] (1 2.3 "four" five) foo
                   ! "Too many arguments in call to" foo "." (five) "are extra"))

;; So now we are ready to declare a few functions and use them in expressions.
;; We will start with conversion functions between primitive types.
(declfn float [int] float)
(declfn round [float] int)
(declfn ceil [float] int)
(declfn floor [float] int)
(declfn trunc [float] int)
(declfn parse-int [string] int)
(declfn parse-float [string] float)
(declfn as-decimal [int] string)
(declfn as-hex [int] string)
(declfn as-scientific [float] string)


;; Now let us use some of these functions in expressions.
(assert
 (typeof (round (+ (parse-float "3.0") (float 2))) int)
 (typeof (round (+ (parse-int "3.0") (float "2"))) int
         ! "Type mismatch in call to function" float
         "2" "has type" string "while" int "is expected"))

;; ### Defining Monomorphic Functions

;; $y_1$ monomorphic functions are defined using the `defn` statement. Its
;; overall structure resembles the definition of the same name in Clojure, but
;; the parameters vector consists of name, type pairs.

;; As our running example, let us consider the following function:
;; ```clojure
;; (defn square [x float]
;;   (* x x))
;; ```

;; This function has a single parameter, `x` of type `float`. It multiplies it
;; by itself to give the square. The return type is not provided explicitly in
;; the definition. It is instead inferred to be `float`.

;; In the following, we work toward giving this definition meaning. We start by
;; defining the meaning of the `declvars-` statement. This is a statement that
;; will allow us to inject the parameters into the scope of the function's
;; body. Following Clojure's convention, the `-` at the end of the name
;; indicates that it is _private_, i.e., only used within this module.
(all [var type vartypes]
     (declvars- [var type & vartypes]) =>
     (all [] (typeof var type))
     (declvars- vartypes))

;; `declvars-` takes a vector of name, type pairs and associates the types to
;; with the names. For example:
(assert
 (given (declvars- [a int
                    b float
                    c string])
        (typeof a int)
        (typeof b float)
        (typeof c string)))

;; Now we are ready to define the translation rule for `defn`.
(all [name params body]
     (defn name params body) =>
     (assert
      (exist []
             (inspect name :symbol
                      ! "The name of a function must be a symbol." name "is given")
             (inspect params :vector
                      ! "A function's parameter list must be a vector" params "is given")
             (given (declvars- params)
                    (exist [type]
                           (typeof body type)))))
     (all [args type]
          (typeof (name & args) type) <-
          (check-defn-types params args name)
          (given (declvars- params)
                 (typeof body type))))

;; A `defn` statement is translated into two statements. The first is an
;; `assert` block that checks three properties of the definition:
;; 1. That the name is a symbol,
;; 2. That the parameters are given in a vector, and
;; 3. That with the parameters defined, the body is a valid expression.
(assert
 (given (defn foo [a int
                   b float]
          (+ a (round b))))
 (given (defn "foo" [a int
                     b float]
          (+ a (round b)))
        ! "The name of a function must be a symbol." "foo" "is given"
        "in" (defn "foo" [a int
                          b float]
               (+ a (round b))))
 (given (defn foo (a int
                     b float)
          (+ a (round b)))
        ! "A function's parameter list must be a vector" (a int b float) "is given"
        "in" (defn foo (a int
                          b float)
               (+ a (round b))))
 (given (defn foo [a int
                   b float]
          (+ a b))
        ! "Type mismatch in +." a "has type" int "while" b "has type" float
        "in" (defn foo [a int
                        b float]
               (+ a b))))

;; The second statement is a rule that accepts calls to the defined function as
;; $y_1$ expressions. It first checks that the argument types match the
;; parameter definition, then it repeats the same `given` condition as in the
;; assertion, but this time type `type` is bound to the expression's type.

;; The argument check is done using `check-defn-types`, which we define next.
(all [params args name]
     (check-defn-types params args name
                       ! "check-defn-types requires a params vector as its first argument."
                       params "is given"))
(all [var var-type params args name]
     (check-defn-types [var var-type & params] args name) <-
     (exist [arg args']
            (= args (arg & args')
               ! "Too few arguments in call to function" name "."
               "missing argument for parameter" var)
            (exist [arg-type]
                   (typeof arg arg-type)
                   (= arg-type var-type
                      ! "Type mismatch for argument" var "of function" name "."
                      "The given argument" arg "is of type" arg-type
                      "while" var-type "is required")
                   (check-defn-types params args' name))))
(all [args name]
     (check-defn-types [] args name) <-
     (= args ()
        ! "Too many argument given to function" name "."
        args "are extra"))

;; Now we can define `square` for real.
(defn square [x float]
  (* x x))

;; We demonstrate it by inferring the type of an expression containing
;; `square`, as we defined it above.
(assert
 (typeof (square 2.0) float)
 (exist [type]
        (typeof (square 2) type)
        ! "Type mismatch for argument" x "of function" square "."
        "The given argument" 2 "is of type" int
        "while" float "is required")
 (exist [type]
        (typeof (square) type)
        ! "Too few arguments in call to function" square "."
        "missing argument for parameter" x)
 (exist [type]
        (typeof (square 2.0 "please round up") type)
        ! "Too many argument given to function" square "."
        ("please round up") "are extra"))

;; ## Algebraic Data Types

;; _Algebraic data types_ (_ADTs_) are user-defined types common in functional
;; programming languages. An ADT has one or more _constructors_, each
;; constructing a different variant of the type, allowing for expressing
;; complex, recursive data structures to be built.

;; We begin by introducing the `type` predicate. It takes a single argument and
;; succeeds if it is a type, or explains why not.
(all [t]
     (type t ! t "is not a type"))

;; We have already encountered some $y_1$ built-in types, so let's define them
;; as such.
(all [] (type int))
(all [] (type float))
(all [] (type string))
(all [] (type bool))
(all [t]
     (type (vector t)) <-
     (type t))
(all [t]
     (type (list t)) <-
     (type t))

(assert
 (type int)
 (type (list string))
 (type (list (vector foo)) ! foo "is not a type"))

;; The base rule for `adt-constructors` is defined here:
(all [name params ctors]
     (adt-constructors name params ctors
                       ! name "is not an algebraic data type"))


;; In $y_1$, ADTs are defined using `deftype` definitions, which is defined as
;; follows.
(all [name params ctors]
     (deftype name params & ctors) =>
     (assert
      (exist []
             (inspect name :symbol ! "Type name must be a symbol." name "is given"))
      (symbol-vector params)
      (given (decltypes- params)
             (type-constructors ctors)))
     (defctors- ctors name params)
     (all [args]
          (type (name & args)) <-
          (type-args args params))
     (all [params' ctors']
          (adt-constructors name params' ctors') <-
          (replace-meta params [params ctors] [params' ctors'])))

;; A defnition is translated to four parts:
;; 1. An assertion that checks the validity of the definition itself.
;; 2. A definition of the constructors.
;; 3. A rule for `type`, defining instances of this ADT as types.
;; 4. A rule for `adt-constructors` that lists the constructors for a given
;;    ADT.

;; `symbol-vector` simply checks that the input is a vector of symbols.
(all [v]
     (symbol-vector v ! "Expected a vector, found" v))
(all [x xs]
     (symbol-vector [x & xs]) <-
     (inspect x :symbol ! "Expected a symbol, found" x)
     (symbol-vector xs))
(all [x xs]
     (symbol-vector []))

(assert
 (symbol-vector [a b c])
 (symbol-vector [a 2 c] ! "Expected a symbol, found" 2)
 (symbol-vector (a b c) ! "Expected a vector, found" (a b c)))

;; `decltypes-` declares all elements of the given vector as types.
(all [t ts]
     (decltypes- [t & ts]) =>
     (all []
          (type t))
     (decltypes- ts))
(assert
 (given (decltypes- [a b c])
        (type a)
        (type b)
        (type c)))

;; `type-constructors` checks the vailidty of the given constructors.
(all [ctors]
     (type-constructors ctors ! "type-constructors expects a list." ctors "was given"))
(all [ctor ctors]
     (type-constructors (ctor & ctors)) <-
     (exist [name params]
            (= ctor (name & params) ! "A constructor must be of the form (name args)." ctor "was given")
            (type-constructor-params params))
     (type-constructors ctors))
(all []
     (type-constructors ()))

(all [params]
     (type-constructor-params params ! "type-constructor-params takes a list." params "is given"))
(all [param params]
     (type-constructor-params (param & params)) <-
     (type param)
     (type-constructor-params params))
(all []
     (type-constructor-params ()))

(assert
 (type-constructors ((foo int float)
                     (bar string)))
 (type-constructors (:foo) ! "A constructor must be of the form (name args)." :foo "was given")
 (type-constructors ((foo x float)
                     (bar string)) ! x "is not a type")
 (type-constructors ((bar string)
                     (foo x float)) ! x "is not a type"))

;; ### Constructors

;; The second statement translated from a `deftype` statement is `defctors-`.
;; This statement translates to a series of `defctor-` statements.
(all [ctor ctors name params]
     (defctors- (ctor & ctors) name params) =>
     (defctor- ctor name params)
     (defctors- ctors name params))


;; `defctor-` defines a single constructor.
(all [cname cparams tname tparams]
     (defctor- (cname & cparams) tname tparams) =>
     (all [args tparams']
          (typeof (cname & args) (tname & tparams')) <-
          (exist [cparams' tparams-as-list]
                 (to-list tparams tparams-as-list)
                 (replace-meta tparams [tparams-as-list cparams] [tparams' cparams'])
                 (ctor-arg-types args cparams' cname))))

;; This definition translates `defctor-` to a rule for `typeof`, giving
;; constructor invocations a type. The naming convention used by this rule
;; makes a distinction between the _constructor's_ name and params (`c` prefix)
;; and the _type's_ name and params (`t` prefix).

;; The meta-variables `tparams` are replaced in both `tparams` and `cparams` to
;; form `tparams'` and `cparams'`. Then we infer the types of the arguments into
;; the free variables in `cparams'`.

;; The type inference is defined as follows.
(all [args params name]
     (ctor-arg-types args params name
                     ! "ctor-arg-types takes a list as its first argument." args "was given"))
(all [arg args params name]
     (ctor-arg-types (arg & args) params name) <-
     (exist [p ps]
            (= params (p & ps)
               ! "Too many arguments in call to constructor" name ":" arg "is extra")
            (exist [t]
                   (typeof arg t)
                   (= p t
                      ! "Type mismatch in call to constructor" name
                      ": expected type" p "but inferred" t))
            (ctor-arg-types args ps name)))
(all [params name]
     (ctor-arg-types () params name) <-
     (exist []
            (= params ()
               ! "Too few arguments in call to constructor" name ":" params "are missing")))

(assert
 (ctor-arg-types (2 "foo") (int string) my-ctor)
 (ctor-arg-types (2 "foo") (int float) my-ctor
                 ! "Type mismatch in call to constructor" my-ctor
                 ": expected type" float "but inferred" string)
 (ctor-arg-types (2 "foo") (int string float) my-ctor
                 ! "Too few arguments in call to constructor" my-ctor ":" (float) "are missing")
 (ctor-arg-types (2 "foo" 3.14) (int string) my-ctor
                 ! "Too many arguments in call to constructor" my-ctor ":" 3.14 "is extra"))

;; The result is that defining an ADT defines its constructors.
(assert
 (given (deftype foo [t]
          (foo-list (list t))
          (foo-vec (vector t)))
        (typeof (foo-vec [1 2 3]) (foo int))))

;; An here are some of the errors that are detected from faulty definitions.
(assert
 (given (deftype foo [t]
          (foo-list (list t))
          (foo-vec (vector x)))
        ! x "is not a type" "in" (deftype foo [t]
                                   (foo-list (list t))
                                   (foo-vec (vector x))))
 (given (deftype :foo [t]
          (foo-list (list t))
          (foo-vec (vector t)))
        ! "Type name must be a symbol." :foo "is given"
        "in" (deftype :foo [t]
               (foo-list (list t))
               (foo-vec (vector t))))
 (given (deftype foo [4]
          (foo-list (list t))
          (foo-vec (vector t)))
        ! "Expected a symbol, found" 4
        "in" (deftype foo [4]
               (foo-list (list t))
               (foo-vec (vector t)))))


               
;; ### Deconstructing ADT Values

;; Deconstruction of ADT values is done through `case` expressions. They have
;; the syntax `(case expr cases...)`, where `expr` is a single expression that
;; evaluates to a ADT value and `cases...` are pattern-expression pairs.

;; We define the type of `case` as follows.
(all [expr cases t]
     (typeof (case expr & cases) t) <-
     (exist [expr-t]
            (typeof expr expr-t)
            (exist [name t-args]
                   (= expr-t (name & t-args)
                      ! "case requires expressions whose types are of the form (name args...)."
                      "An expression of type" expr-t "was given")
                   (exist [t-args-v ctors t']
                          (to-vec t-args t-args-v)
                          (adt-constructors name t-args-v ctors)
                          (cases-for-ctors ctors cases t')
                          (= t t' ! "Type mismatch in case expression. Expected" t "but inferred" t')))))

;; We first infer the type of `expr`. Then, after checking this is an ADT, we
;; find its constructors and check the cases against them.

;; The last part is done using `cases-for-ctors`:
(all [ctors cases t]
     (cases-for-ctors ctors cases t
                      ! "cases-for-ctors takes a list of constructors as its first argument."
                      ctors "is given"))
(all [ctor ctors cases t]
     (cases-for-ctors (ctor & ctors) cases t) <-
     (exist [dtor expr r-cases]
            (= cases (dtor expr & r-cases)
               ! "case expression missing case for constructor" ctor)
            (case-for-ctor ctor dtor expr t)
            (cases-for-ctors ctors r-cases t)))
(all [cases t]
     (cases-for-ctors () cases t) <-
     (= cases ()
        ! "Too many cases in case express."
        cases "do not have corresponding constructors"))

(all [ctor dtor expr t]
     (case-for-ctor ctor dtor expr t
                    ! "Invalid constructor" ctor))
(all [name params dtor expr t]
     (case-for-ctor (name & params) dtor expr t) <-
     (exist [vars]
            (= dtor (name & vars)
               ! "Expected destructor for constructor" name "but got" dtor)
            (given (declparams- vars params)
                   (exist [t']
                          (typeof expr t')
                          (= t' t 
                             ! "Type mismatch in case" name ":"
                             "expected type" t "but inferred type" t')))))

;; The last rule defines the semantics of a _destructor_, a term of the form
;; `(name vars...)`, where `name` is the same name as one of the constructors
;; and `vars...` are zero or more symbols.

;; The important bit is that we declare these symbols based on the types they
;; take in the constructor, using the `declparams-` statement, defined below.
(all [var vars params
      param r-params]
     (declparams- (var & vars) params) =>
     (assert
      (exist []
             (inspect var :symbol ! "Expected symbol, found" var)
             (= params (param & r-params)
                ! "Too many variables in destructor." (var & vars) "are not matched by constructor parameters.")))
     (all []
          (typeof var param))
     (declparams- vars r-params))
(all [params]
     (declparams- () params) =>
     (assert
      (exist []
             (= params ()
                ! "Too few variables in destructor. Missing variables for" params))))

(assert
 (given (declparams- (a b c) (int string float)))
 (given (declparams- (a 3 c) (int string float))
        ! "Expected symbol, found" 3
        "in" (declparams- (a 3 c) (int string float)))
 (given (declparams- (a b) (int string float))
        ! "Too few variables in destructor. Missing variables for" (float)
        "in" (declparams- (a b) (int string float)))
 (given (declparams- (a b c d) (int string float))
        ! "Too many variables in destructor." (d) "are not matched by constructor parameters."
        "in" (declparams- (a b c d) (int string float))))

;; Now we are ready to test our `case` expression.
(assert
 (given (deftype foo [t]
          (foo-list (list t))
          (foo-vec (vector t)))
        (given (declvars- [x (foo int)])
               (typeof (case x
                         (foo-list l) 3
                         (foo-vec v) 2) int))))

;; ## Type Classes

;; In contrast to monomorphic functions, whose type signatures are constant,
;; _polimorphic functions_ are functions whose signature may change. Two types
;; of polimorphism supported by $y_1$: _parametric polimorphism_, in which some
;; types in the signature are completely open and can take any value, and
;; _ad-hoc polimorphism_, where some types in the signature can take certain
;; values, as long as some properties are guarantees for them.

;; Ad-hoc polimorphism is implemented using _type classes_, which we cover
;; here.

;; ### Type Class Definition

;; A type-class is defined using the `defclass` statement, defined as follows.
(all [name types methods]
     (defclass name types
       & methods) =>
     (assert
      (exist []
             (inspect name :symbol
                      ! "A class name needs to be a symbol." name "is given")
             (class-type-symbols types name)
             (class-methods methods)))
     (all [type' types']
          (name type' types'
                ! type' "is not a type in class" name))
     (defmethods- name types methods)
     (all [types' methods']
          (methods-for-class name types' methods') <-
          (replace-meta types [types methods] [types' methods'])))

;; **TODO:** Reorganize the rules so that this is not necessary.
(all [name types methods]
     (defmethods- name types methods) =>)


;; This definition translates a `defclass` statement into three things:
;; 1. An assertion that checks that the `name` is a symbol, `types` is a vector
;;    of symbols and that the `methods` are valid method definitions (we will
;;    define `class-type-symbols` and `class-methods` later).
;; 2. A base rule for a predicate named after the class. This predicate takes
;;    two arguments, the `type` that is supposed to be a member of the class
;;    and `types`, auxiliary types that are derived from this type.
;; 3. A definition of all methods as individual functions.
;; 4. A rule for `methods-for-class`, providing the methods defined for this
;;    class. The base rule for this predicate is provided below. It replaces
;;    the symbols representing the types with free variables.
(all [class types methods]
     (methods-for-class class types methods
                        ! class "is not defined as a type-class"))

;; `class-type-symbols` is defined as follows.
(all [syms class]
     (class-type-symbols syms class
                         ! "A class types list needs to be a vector."
                         syms "is given"))
(all [sym syms class]
     (class-type-symbols [sym & syms] class) <-
     (inspect sym :symbol ! "A symbol expected." sym "was given")
     (class-type-symbols syms class))
(all [sym class]
     (class-type-symbols [sym] class) <-
     (inspect sym :symbol ! "A symbol expected." sym "was given"))
(all [class]
     (class-type-symbols [] class ! "Empty types list for class" class))

;; We will now define `class-methods`.
(all [methods]
     (class-methods methods
                    ! "class-methods requires a list of methods." methods "is given"))
(all [method methods]
     (class-methods (method & methods)) <-
     (class-method method)
     (class-methods methods))
(all []
     (class-methods ()))

;; This definition applies `class-method` on each element. So let us define
;; `class-method`, and by that define what is legal as a method in a class.
(all [method]
     (class-method method
                   ! method "is not a legal class method declaration"))
(all [name params type]
     (class-method (declfn name params type)) <-
     (inspect name :symbol
              ! "The name of a method must be a symbol." name "is given")
     (inspect params :vector
              ! "The parameter list of a method must be a vector." params "is given"))

;; After the base definition that rejects everything, we define a rule to
;; accept declarations similar to
;; [those of monomorphic functions](#declaring-monomorphic-functions).
;; Polymorphic functions are supported too, but we defer their definition until
;; later.

;; #### Example Classes

;; Now we can define our first type classes. `Show` is a class with one method:
;; `show`, which takes a single argument of a member type and returns a string
;; representing it.
(defclass Show [t]
  (declfn show [t] string))

;; `Convertable-` is a less practical class, with one method: `convert-`. This
;; class demonstrates the idea of an _auxiliary type_ being introduced in
;; addition to the self-type (the first type in the types list).
(defclass Convertable- [t t']
  (declfn convert- [t] t'))

;; `convert-` takes an argument of the self-type `t` and returns a value of
;; type `t'`, which is an auxiliary type. Each instance will then determine the
;; corresponding `t'` for each `t`. This demonstrates the "ad-hoc" in "ad-hoc
;; polymorphism".

;; These two class definitions define cases for `methods-for-class` and base
;; rules for predicates `Show` and `Convertable-`.
(assert
 (methods-for-class Show [x] ((declfn show [x] string)))
 (methods-for-class Convertable- [x y] ((declfn convert- [x] y)))
 (Show foo [] ! foo "is not a type in class" Show)
 (exist [t']
        (Convertable- foo [t'])
        ! foo "is not a type in class" Convertable-))

;; Note that in the call to `methods-for-class` we can use any value in the
;; type list (we used `x` for `Show` and `x` and `y` for `Convertable-`).
;; Corresponding values appear in the method declaration.

;; Let us test a few bad definitions.
(assert
 (given (defclass :Show [t])
        ! "A class name needs to be a symbol." :Show "is given"
        "in" (defclass :Show [t]))
 (given (defclass Show (t))
        ! "A class types list needs to be a vector." (t) "is given"
        "in" (defclass Show (t)))
 (given (defclass Show [])
        ! "Empty types list for class" Show
        "in" (defclass Show []))
 (given (defclass Show [:t])
        ! "A symbol expected." :t "was given"
        "in" (defclass Show [:t]))
 (given (defclass Show [t]
          (not a declfn))
        ! (not a declfn) "is not a legal class method declaration"
        "in" (defclass Show [t]
                                                                          (not a declfn))))

;; #### Method Definitions

;; `defmethod-` is defined for different kinds of methods. Currently, only
;; monomorphic methods are supported. The following is their definition.
(all [class types method params ret-type]
     (defmethod- class types (declfn method params ret-type)) =>
     (all [args ret-type']
          (typeof (method & args) ret-type') <-
          (exist [self-type aux-types params']
                 (replace-meta types
                               [types params ret-type]
                               [[self-type & aux-types] params' ret-type'])
                 (check-decl-types params' args method)
                 (class self-type aux-types ! "in method call" ? "with param types" params'))))

;; A `defmethods-` statement translates into individual `defmethod-`
;; statements.
(all [name types method methods]
     (defmethods- name types (method & methods)) =>
     (defmethod- name types method)
     (defmethods- name types methods))

;; With the above definition of the `Show` class (and no instances), we expect
;; type-checking on the `show` function to fail on the call to the class
;; predicate.
(assert
 (exist [t]
        (typeof (show 2) t)
        ! int "is not a type in class" Show "in method call" (show 2) "with param types" [int]))

;; If we bridge this gap, we get a valid expression.
(assert
 (given (all [] (Show int []))
        (typeof (show 2) string))
 (given (all [] (Convertable- int [float]))
        (typeof (convert- 2) float)))

;; ### Instance Definitions

;; In contrast to [class definitions](#type-class-definition), which define new
;; type classes and declare their methods, _instance definitions_ define a type
;; or a family of types as a member / members of a type class, while providing
;; implementations for the declared methods.

;; We now proceed to defining the meaning of the `definstance` statement.
(all [free-types constraints class types methods
      ;; Internal vars
      t ts]
     (definstance free-types constraints class types
       & methods) =>
     (assert
      (symbol-vector free-types)
      (given (decltypes- free-types)
             (type-constraints constraints))
      (exist [classdef-types method-decls]
             (methods-for-class class classdef-types method-decls)
             (= classdef-types types
                ! "The types" types "do not match the type list" classdef-types
                "declared for class" class)
             (given (declconstraints- constraints)
                    (instance-method-defs methods method-decls)))
      (= types [t & ts]))
     (with-meta [$free-types free-types
                 $constraints constraints
                 $t t
                 $ts ts]
       (all $free-types
          (class $t $ts) <-
          (check-constraints $constraints ! "when checking constraint for instance" ? "of class" class))))

;; Like other definitions, `definstance` translates into an assertion and a
;; rule. However, here we see a special interaction between them. The assertion
;; binds some free variables that we marked as `Internal vars` in the
;; translation rule. These variables are then used in the rule. Specifically,
;; they replace meta-vars in the instance `$free-types` with unbound variables.
;; These variables are then used in the rule.

;; The rule contributes a solution for the class predicate (the predicate
;; whose name is the name of the class), making the instance's type a solution.
;; The type `t`, used as key, is determined by the `assert` block. This make
;; sure that when the rule is being added, `t` corresponds to a concrete type,
;; contributing a concrete case to the predicate.

;; The assertion works as follows. First it checks that the given `$free-types`
;; are all symbols given in a vector. Then it checks that if these symbols
;; were types, the given `$constraints` were valid. Then it checks the matching
;; of the method definitions to the declarations in the `defclass`. Finally, it
;; replaces the meta-vars and prepares the terms for the instance rule, as
;; described above.

;; #### Type Constraints

;; Type constraints are terms of the form `(class type & types)`, where `class`
;; is a name of a class, `type` is a term representing an instance of this
; class and `types` are terms representing the auxiliary types of this class.

;; `type-constraints` takes a vector of type constraints and succeeds if they
;; are valid.
(all [constraints]
     (type-constraints constraints
                       ! "type-constraints takes a vector of constraints."
                       constraints "was given"))
(all [constraint constraints]
     (type-constraints [constraint & constraints]) <-
     (type-constraint constraint)
     (type-constraints constraints))
(all []
     (type-constraints []))

;; To define the validity of each type constraint, we first define
;; `match-constraint-types`, which checks that for each type in the vector
;; defined in the `defclass` there is a corresponding type in the type
;; constraint.
(all [types classdef-types class]
     (match-constraint-types types classdef-types class
                             ! "match-constraint-types takes a list of types."
                             types "was given"))
(all [t ts classdef-t class]
     (match-constraint-types (t & ts) classdef-t class) <-
     (exist [classdef-t' classdef-ts']
            (= classdef-t [classdef-t' & classdef-ts']
               ! "Too many type arguments given to class" class ":"
               t "is unmatched")
            (type t)
            (match-constraint-types ts classdef-ts' class)))
(all [classdef-t class]
     (match-constraint-types () classdef-t class) <-
     (= classdef-t []
        ! "Too few arguments given to class" class ":"
        classdef-t "are missing"))

(assert
 (match-constraint-types (int string) [x y] MyClass)
 (match-constraint-types (int foo) [x y] MyClass
                         ! foo "is not a type")
 (match-constraint-types (int string float) [x y] MyClass
                         ! "Too many type arguments given to class" MyClass ":"
                         float "is unmatched")
 (match-constraint-types (int) [x y] MyClass
                         ! "Too few arguments given to class" MyClass ":"
                         [y] "are missing"))

;; `type-constraint` succeeds if the given term is a valid type constraint.
(all [constraint]
     (type-constraint constraint
                      ! "Expected (class types...). Found" constraint))
(all [class types]
     (type-constraint (class & types)) <-
     (exist [classdef-types _method-decls]
            (methods-for-class class classdef-types _method-decls)
            (match-constraint-types types classdef-types class)))

(assert
 (type-constraints [(Show string) (Convertable- int float)])
 (type-constraints [(Show string) (Convertable- int foo)]
                   ! foo "is not a type")
 (type-constraints [(Show string) (NotAClass int float)]
                   ! NotAClass "is not defined as a type-class")
 (type-constraints [(Show string int) (Convertable- int float)]
                   ! "Too many type arguments given to class" Show ":"
                   int "is unmatched")
 ;; **TODO:** This should fail.
 (type-constraints [(Show) (Convertable- int)]))

;; Given constraints with actual types, `check-constraints` checks that they
;; hold, i.e., that there are instances to match them.
(all [constraints]
     (check-constraints constraints
                        ! "check-constraints expects a vector of constraints."
                        constraints "was given"))
(all [constraint constraints]
     (check-constraints [constraint & constraints]) <-
     (check-constraint constraint)
     (check-constraints constraints))
(all []
     (check-constraints []))

;; This is acheived by calling the class predicate for each constraint.
(all [constraint]
     (check-constraint constraint
                       ! "Expected (class types...). Found" constraint))
(all [class types]
     (check-constraint (class & types)) <-
     (exist [t ts]
            (= types (t & ts) ! "A type constraint must contain at least one type.")
            (exist [ts-v]
                   (to-vec ts ts-v)
                   (class t ts-v))))

(assert
 (given (all [] (Show int []))
        (check-constraint (Show int)))
 (given (all [] (Convertable- int [float]))
        (check-constraint (Convertable- int float)))
 (check-constraint (Show)
                   ! "A type constraint must contain at least one type."))

;; Finally, constraints can be used to inject assumptions into a scope.
;; `declconstraints-` does this for a vector of constraints.
(all [class type types types-vec constraints]
     (declconstraints- [(class type & types) & constraints]) =>
     (assert
      (to-vec types types-vec))
     (all []
          (class type types-vec))
     (declconstraints- constraints))

(assert
 (given (declconstraints- [(Show t) (Convertable- t1 t2)])
        (exist []
               (Show t [])
               (Convertable- t1 [t2]))))

;; #### Matching Method Definitions to Declarations

;; `defclass` declares methods that need to be defined for every instance.
;; These methods need to be defined in each `definstance` of that class, at the
;; same order.

;; `instance-method-defs` takes a list of method definitions and a list of
;; declarations and succeeds if the two match.
(all [defs decls]
     (instance-method-defs defs decls
                           ! "instance-method-defs takes a list of definitions."
                           defs "was given"))
(all [def defs decls]
     (instance-method-defs (def & defs) decls) <-
     (exist [decl decls']
            (= decls (decl & decls')
               ! "Too many method definitions in instance." def "is unmatched")
            (instance-method-def-for-decl decl def)
            (instance-method-defs defs decls')))
(all [decls]
     (instance-method-defs () decls) <-
     (= decls ()
        ! "Too few method definitions in instance. Definitions for" decls "are missing"))

(all [def decl]
     (instance-method-def-for-decl decl def ! decl "is not a method declaration"))

;; So far we have only seen one type of method declaration: the one for
;; monomorphic methods. The following rule accepts matching definitions.
(all [name param-types ret-type def]
     (instance-method-def-for-decl (declfn name param-types ret-type) def) <-
     (exist [param-names body]
            (= def (defn name param-names body)
               ! "Expected a defn of method" name "but found" def)
            (symbol-vector param-names)
            (exist [inferred-type]
                   (given (defparams- param-names param-types)
                          (typeof body inferred-type))
                   (= inferred-type ret-type
                      ! "The body of method" name "should evaluate to type" ret-type
                      "but" inferred-type "is inferred"))))

;; This rule matches a `declfn` method declaration. It first checks that the
;; corresponding definition is a `defn` of the same name. Then it checks that
;; the parameter names are given in a vector of symbols. Then it defines these
;; params as having the types mentioned in the declaration and tries to infer
;; the type of the body, assuming this definition. The type should match the
;; type declared in the declaration.

;; Defining the parameters is done using the following translation rule.
(all [name names type types]
     (defparams- [name & names] [type & types]) =>
     (all []
          (typeof name type))
     (defparams- names types))

;; #### Instance Examples

;; Here are some definitions of instances for the `Show` and `Convertable-`.
(definstance [] [] Show [string]
  (defn show [s]
    s))
(definstance [] [] Show [int]
  (defn show [n]
    (as-decimal n)))
(definstance [] [] Convertable- [float int]
  (defn convert- [n]
    (round n)))

;; These definitions are for concrete types. In the first two we define two
;; instances for `Show`: `int` and `string`. We use `defn` to define each
;; method declared using `declfn` in the corresponding `defclass`. In the third
;; definition we define `float` as an instance of `Convertable-`, which
;; converts the input to `int` by rounding it.

;; The effect of these definitions is that the methods (`show` and `convert-`)
;; are now defined for a select input types. 
(assert
 (typeof (show "foo") string)
 (typeof (show 42) string)
 (exist [t]
        (typeof (show 42.0) t)
        ! float "is not a type in class" Show "in method call" (show 42.0) "with param types" [float])
 (typeof (convert- 42.0) int))

;; Following are some erroneous examples, showing the different checks we have
;; defined.
(assert
 (given (definstance [] [] Show [string]
          (defn display [s]
            s))
        ! "Expected a defn of method" show "but found" (defn display [s]
                                                         s)
        "in" (definstance [] [] Show [string]
               (defn display [s]
                 s)))
 (given (definstance [] [] Show [string]
          (defn show (s)
            s))
        ! "Expected a vector, found" (s) "in" (definstance [] [] Show [string]
                                                (defn show (s)
                                                  s)))
 (given (definstance [] [] Show [int]
          (defn show [s]
            s))
        ! "The body of method" show "should evaluate to type" string
        "but" int "is inferred"
        "in" (definstance [] [] Show [int]
               (defn show [s]
                 s))))

;; In the next example we define a polymorphic instance. We first define
;; `showable-`, a container type for values of any type.
(deftype showable- [t] (showable- t))

;; We now define `(showable- t)` as an instance of `Convertable-` for any `t` in
;; `Show`, as follows:
(definstance [t] [(Show t)] Convertable- [(showable- t) string]
  (defn convert- [x]
    (case x
      (showable- v) (show v))))

;; With this definition, `convert-` can be called on `showable-` instances for
;; which the value is an instance of `Show`.
(assert
 (typeof (convert- (showable- 42)) string))

;; If this is not the case, we receive a detailed explanation.
(assert
 (exist [t]
        (typeof (convert- (showable- 42.0)) t)
        ! float "is not a type in class" Show
        "when checking constraint for instance" (showable- float)
        "of class" Convertable-
        "in method call" (convert- (showable- 42.0))
        "with param types" [(showable- float)]))

